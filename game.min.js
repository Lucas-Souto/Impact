/*! Built with Krater */


class Input
{static KEY={'MOUSE1':-1,'MOUSE2':-3,'MWHEEL_UP':-4,'MWHEEL_DOWN':-5,'BACKSPACE':8,'TAB':9,'ENTER':13,'PAUSE':19,'CAPS':20,'ESC':27,'SPACE':32,'PAGE_UP':33,'PAGE_DOWN':34,'END':35,'HOME':36,'LEFT_ARROW':37,'UP_ARROW':38,'RIGHT_ARROW':39,'DOWN_ARROW':40,'INSERT':45,'DELETE':46,'_0':48,'_1':49,'_2':50,'_3':51,'_4':52,'_5':53,'_6':54,'_7':55,'_8':56,'_9':57,'A':65,'B':66,'C':67,'D':68,'E':69,'F':70,'G':71,'H':72,'I':73,'J':74,'K':75,'L':76,'M':77,'N':78,'O':79,'P':80,'Q':81,'R':82,'S':83,'T':84,'U':85,'V':86,'W':87,'X':88,'Y':89,'Z':90,'NUMPAD_0':96,'NUMPAD_1':97,'NUMPAD_2':98,'NUMPAD_3':99,'NUMPAD_4':100,'NUMPAD_5':101,'NUMPAD_6':102,'NUMPAD_7':103,'NUMPAD_8':104,'NUMPAD_9':105,'MULTIPLY':106,'ADD':107,'SUBSTRACT':109,'DECIMAL':110,'DIVIDE':111,'F1':112,'F2':113,'F3':114,'F4':115,'F5':116,'F6':117,'F7':118,'F8':119,'F9':120,'F10':121,'F11':122,'F12':123,'SHIFT':16,'CTRL':17,'ALT':18,'PLUS':187,'COMMA':188,'MINUS':189,'PERIOD':190};bindings={};actions={};presses={};locks={};delayedKeyup={};isUsingMouse=false;isUsingKeyboard=false;isUsingAccelerometer=false;mouse={x:0,y:0};accel={x:0,y:0,z:0};initMouse()
{if(this.isUsingMouse)return;this.isUsingMouse=true;KG.system.canvas.addEventListener('wheel',this.mousewheel.bind(this),false);KG.system.canvas.addEventListener('contextmenu',this.contextmenu.bind(this),false);KG.system.canvas.addEventListener('mousedown',this.keydown.bind(this),false);KG.system.canvas.addEventListener('mouseup',this.keyup.bind(this),false);KG.system.canvas.addEventListener('mousemove',this.mousemove.bind(this),false);if(KG.ua.touchDevice)
{KG.system.canvas.addEventListener('touchstart',this.keydown.bind(this),false);KG.system.canvas.addEventListener('touchend',this.keyup.bind(this),false);KG.system.canvas.addEventListener('touchcancel',this.keyup.bind(this),false);KG.system.canvas.addEventListener('touchmove',this.mousemove.bind(this),false);KG.system.canvas.addEventListener('MSPointerDown',this.keydown.bind(this),false);KG.system.canvas.addEventListener('MSPointerUp',this.keyup.bind(this),false);KG.system.canvas.addEventListener('MSPointerMove',this.mousemove.bind(this),false);KG.system.canvas.style.msTouchAction='none';}}
initKeyboard()
{if(this.isUsingKeyboard)return;this.isUsingKeyboard=true;window.addEventListener('keydown',this.keydown.bind(this),false);window.addEventListener('keyup',this.keyup.bind(this),false);}
initAccelerometer()
{if(this.isUsingAccelerometer)return;this.isUsingAccelerometer=true;window.addEventListener('devicemotion',this.devicemotion.bind(this),false);}
mousewheel(event)
{const code=event.deltaY<0?Input.KEY.MWHEEL_UP:Input.KEY.MWHEEL_DOWN;const action=this.bindings[code];if(action)
{this.actions[action]=true;this.presses[action]=true;this.delayedKeyup[action]=true;event.stopPropagation();event.preventDefault();}}
mousemove(event)
{const internalWidth=KG.system.canvas.offsetWidth||KG.system.realWidth;const scale=KG.system.scale*(internalWidth/KG.system.realWidth);let pos={left:0,top:0};if(KG.system.canvas.getBoundingClientRect)pos=KG.system.canvas.getBoundingClientRect();const ev=event.touches?event.touches[0]:event;this.mouse.x=(ev.clientX-pos.left)/scale;this.mouse.y=(ev.clientY-pos.top)/scale;}
contextmenu(event)
{if(this.bindings[Input.KEY.MOUSE2])
{event.stopPropagation();event.preventDefault();}}
keydown(event)
{const tag=event.target.tagName;if(tag==='INPUT'||tag==='TEXTAREA')return;const code=event.type=='keydown'?event.keyCode:(event.button==2?Input.KEY.MOUSE2:Input.KEY.MOUSE1);if(code<0&&!KG.ua.mobile)window.focus();if(event.type=='touchstart'||event.type=='mousedown')this.mousemove(event);const action=this.bindings[code];if(action)
{this.actions[action]=true;if(!this.locks[action])
{this.presses[action]=true;this.locks[action]=true;}
event.preventDefault();}}
keyup(event)
{const tag=event.target.tagName;if(tag==='INPUT'||tag==='TEXTAREA')return;const code=event.type=='keyup'?event.keyCode:(event.button==2?Input.KEY.MOUSE2:Input.KEY.MOUSE1);const action=this.bindings[code];if(action)
{this.delayedKeyup[action]=true;event.preventDefault();}}
devicemotion(event)
{this.accel=event.accelerationIncludingGravity;}
bind(key,action)
{if(key<0)this.initMouse();else if(key>0)this.initKeyboard();this.bindings[key]=action;}
bindTouch(selector,action)
{const element=KG.$(selector);const that=this;element.addEventListener('touchstart',(ev)=>that.touchStart(ev,action),false);element.addEventListener('touchend',(ev)=>that.touchEnd(ev,action),false);element.addEventListener('MSPointerDown',(ev)=>that.touchStart(ev,action),false);element.addEventListener('MSPointerUp',(ev)=>that.touchEnd(ev,action),false);}
unbind(key)
{const action=this.bindings[key];this.delayedKeyup[action]=true;this.bindings[key]=null;}
unbindAll()
{this.bindings={};this.actions={};this.presses={};this.locks={};this.delayedKeyup={};}
state(action)
{return this.actions[action];}
pressed(action)
{return this.presses[action];}
released(action)
{return!!this.delayedKeyup[action];}
clearPressed()
{for(let action in this.delayedKeyup)
{this.actions[action]=false;this.locks[action]=false;}
this.delayedKeyup={};this.presses={};}
touchStart(event,action)
{this.actions[action]=true;this.presses[action]=true;event.stopPropagation();event.preventDefault();return false;}
touchEnd(event,action)
{this.delayedKeyup[action]=true;event.stopPropagation();event.preventDefault();return false;}}
class Timer
{target=0;base=0;last=0;pausedAt=0;static _last=0;static time=Number.MIN_VALUE;static timeScale=1;static maxStep=0.05;constructor(seconds)
{this.base=Timer.time;this.last=Timer.time;this.target=seconds||0;}
set(seconds)
{this.target=seconds||0;this.base=Timer.time;this.pausedAt=0;}
reset()
{this.base=Timer.time;this.pausedAt=0;}
tick()
{var delta=Timer.time-this.last;this.last=Timer.time;return(this.pausedAt?0:delta);}
delta()
{return(this.pausedAt||Timer.time)-this.base-this.target;}
pause()
{if(!this.pausedAt)this.pausedAt=Timer.time;}
unpause()
{if(this.pausedAt)
{this.base+=Timer.time-this.pausedAt;this.pausedAt=0;}}
static step=function()
{const current=Date.now();const delta=(current-Timer._last)/1000;Timer.time+=Math.min(delta,Timer.maxStep)*Timer.timeScale;Timer._last=current;};}
class System
{static SCALE={CRISP:function(canvas,context)
{KG.setVendorAttribute(context,'imageSmoothingEnabled',false);canvas.style.imageRendering='-moz-crisp-edges';canvas.style.imageRendering='-o-crisp-edges';canvas.style.imageRendering='-webkit-optimize-contrast';canvas.style.imageRendering='crisp-edges';canvas.style.msInterpolationMode='nearest-neighbor';},SMOOTH:function(canvas,context)
{KG.setVendorAttribute(context,'imageSmoothingEnabled',true);canvas.style.imageRendering='';canvas.style.msInterpolationMode='';}};static scaleMode=System.SCALE.SMOOTH;DRAW={AUTHENTIC:(p)=>{return Math.round(p)*this.scale;},SMOOTH:(p)=>{return Math.round(p*this.scale);},SUBPIXEL:(p)=>{return p*this.scale;}};drawMode=this.DRAW.SMOOTH;onGameSet=()=>{}
fps=30;width=320;height=240;realWidth=320;realHeight=240;scale=1;tick=0;animationId=0;newGameClass=null;running=false;delegate=null;clock=null;canvas=null;context=null;constructor(canvasId,fps,width,height,scale)
{this.fps=fps;this.clock=new Timer();this.canvas=KG.$(canvasId);this.resize(width,height,scale);this.context=this.canvas.getContext('2d');this.getDrawPos=this.drawMode;if(this.scale!=1)System.scaleMode=System.SCALE.CRISP;System.scaleMode(this.canvas,this.context);}
resize(width,height,scale)
{this.width=width;this.height=height;this.scale=scale||this.scale;this.realWidth=this.width*this.scale;this.realHeight=this.height*this.scale;this.canvas.width=this.realWidth;this.canvas.height=this.realHeight;}
setGame(gameClass)
{if(this.running)this.newGameClass=gameClass;else this.setGameNow(gameClass);this.onGameSet();}
setGameNow(gameClass)
{KG.game=new(gameClass)();KG.system.setDelegate(KG.game);this.onGameSet();}
setDelegate(object)
{if(typeof(object.run)==='function')
{this.delegate=object;this.startRunLoop();}
else throw('System.setDelegate: No run() function in object');}
stopRunLoop()
{KG.clearAnimation(this.animationId);this.running=false;}
startRunLoop()
{this.stopRunLoop();this.animationId=KG.setAnimation(this.run.bind(this));this.running=true;}
clear(color)
{this.context.fillStyle=color;this.context.fillRect(0,0,this.realWidth,this.realHeight);}
run()
{Timer.step();this.tick=this.clock.tick();this.delegate.run();KG.input.clearPressed();if(this.newGameClass)
{this.setGameNow(this.newGameClass);this.newGameClass=null;}}
getDrawPos=null;}
class SoundManager
{clips={};volume=1;format=null;constructor()
{if(!Sound.enabled||!window.Audio)
{Sound.enabled=false;return;}
const probe=new Audio();for(let i=0;i<Sound.use.length;i++)
{let format=Sound.use[i];if(probe.canPlayType(format.mime))
{this.format=format;break;}}
if(!this.format)Sound.enabled=false;if(Sound.enabled&&Sound.useWebAudio)
{this.audioContext=new AudioContext();this.boundWebAudioUnlock=this.unlockWebAudio.bind(this);KG.system.canvas.addEventListener('touchstart',this.boundWebAudioUnlock,false);KG.system.canvas.addEventListener('mousedown',this.boundWebAudioUnlock,false);}}
unlockWebAudio()
{KG.system.canvas.removeEventListener('touchstart',this.boundWebAudioUnlock,false);KG.system.canvas.removeEventListener('mousedown',this.boundWebAudioUnlock,false);const buffer=this.audioContext.createBuffer(1,1,22050);const source=this.audioContext.createBufferSource();source.buffer=buffer;source.connect(this.audioContext.destination);source.start(0);}
load(path,multiChannel,loadCallback)
{if(multiChannel&&Sound.useWebAudio)return this.loadWebAudio(path,multiChannel,loadCallback);else return this.loadHTML5Audio(path,multiChannel,loadCallback);}
loadWebAudio(path,multiChannel,loadCallback)
{const realPath=KG.prefix+path.replace(/[^\.]+$/,this.format.ext)+KG.nocache;if(this.clips[path])return this.clips[path];const audioSource=new WebAudioSource();this.clips[path]=audioSource;const request=new XMLHttpRequest();request.open('GET',realPath,true);request.responseType='arraybuffer';const that=this;request.onload=function(ev)
{that.audioContext.decodeAudioData(request.response,function(buffer)
{audioSource.buffer=buffer;if(loadCallback)loadCallback(path,true,ev);},function(ev)
{if(loadCallback)loadCallback(path,false,ev);});};request.onerror=function(ev)
{if(loadCallback){loadCallback(path,false,ev);}};request.send();return audioSource;}
loadHTML5Audio(path,multiChannel,loadCallback)
{const realPath=KG.prefix+path.replace(/[^\.]+$/,this.format.ext)+KG.nocache;if(this.clips[path])
{if(this.clips[path]instanceof WebAudioSource)return this.clips[path];if(multiChannel&&this.clips[path].length<Sound.channels)
{for(let i=this.clips[path].length;i<Sound.channels;i++)
{const a=new Audio(realPath);a.load();this.clips[path].push(a);}}
return this.clips[path][0];}
const clip=new Audio(realPath);if(loadCallback)
{if(KG.ua.mobile)setTimeout(()=>loadCallback(path,true,null),0);else
{clip.addEventListener('canplaythrough',function cb(ev)
{clip.removeEventListener('canplaythrough',cb,false);loadCallback(path,true,ev);},false);clip.addEventListener('error',(ev)=>loadCallback(path,false,ev),false);}}
clip.preload='auto';clip.load();this.clips[path]=[clip];if(multiChannel)
{for(let i=1;i<Sound.channels;i++)
{let a=new Audio(realPath);a.load();this.clips[path].push(a);}}
return clip;}
get(path)
{const channels=this.clips[path];if(channels&&channels instanceof WebAudioSource)return channels;for(let i=0,clip;clip=channels[i++];)
{if(clip.paused||clip.ended)
{if(clip.ended)clip.currentTime=0;return clip;}}
channels[0].pause();channels[0].currentTime=0;return channels[0];}}
class Music
{tracks=[];namedTracks={};currentTrack=null;currentIndex=0;random=false;_volume=1;_loop=false;_fadeInterval=0;_fadeTimer=null;_endedCallbackBound=null;constructor()
{this._endedCallbackBound=this._endedCallback.bind(this);Object.defineProperty(this,"volume",{get:this.getVolume.bind(this),set:this.setVolume.bind(this)});Object.defineProperty(this,"loop",{get:this.getLooping.bind(this),set:this.setLooping.bind(this)});}
add(music,name)
{if(!Sound.enabled)return;const path=music instanceof Sound?music.path:music;const track=KG.soundManager.load(path,false);if(track instanceof WebAudioSource)
{KG.system.stopRunLoop();throw(`Sound'${path}'loaded as Multichannel but used for Music.`+"Set the multiChannel param to false when loading, e.g.: new Sound(path, false)");}
track.loop=this._loop;track.volume=this._volume;track.addEventListener('ended',this._endedCallbackBound,false);this.tracks.push(track);if(name)this.namedTracks[name]=track;if(!this.currentTrack)this.currentTrack=track;}
next()
{if(!this.tracks.length)return;this.stop();this.currentIndex=this.random?Math.floor(Math.random()*this.tracks.length):(this.currentIndex+1)%this.tracks.length;this.currentTrack=this.tracks[this.currentIndex];this.play();}
pause()
{if(!this.currentTrack)return;this.currentTrack.pause();}
stop()
{if(!this.currentTrack)return;this.currentTrack.pause();this.currentTrack.currentTime=0;}
play(name)
{if(name&&this.namedTracks[name])
{const newTrack=this.namedTracks[name];if(newTrack!=this.currentTrack)
{this.stop();this.currentTrack=newTrack;}}
else if(!this.currentTrack)return;this.currentTrack.play();}
getLooping()
{return this._loop;}
setLooping(l)
{this._loop=l;for(let i in this.tracks)this.tracks[i].loop=l;}
getVolume()
{return this._volume;}
setVolume(v)
{this._volume=v.limit(0,1);for(let i in this.tracks)this.tracks[i].volume=this._volume;}
fadeOut(time)
{if(!this.currentTrack)return;clearInterval(this._fadeInterval);this._fadeTimer=new Timer(time);this._fadeInterval=setInterval(this._fadeStep.bind(this),50);}
_fadeStep()
{const v=this._fadeTimer.delta().map(-this._fadeTimer.target,0,1,0).limit(0,1)*this._volume;if(v<=0.01)
{this.stop();this.currentTrack.volume=this._volume;clearInterval(this._fadeInterval);}
else this.currentTrack.volume=v;}
_endedCallback()
{if(this._loop)this.play();else this.next();}}
class Sound
{path='';volume=1;currentClip=null;multiChannel=true;_loop=false;static FORMAT={MP3:{ext:'mp3',mime:'audio/mpeg'},M4A:{ext:'m4a',mime:'audio/mp4; codecs=mp4a.40.2'},OGG:{ext:'ogg',mime:'audio/ogg; codecs=vorbis'},WEBM:{ext:'webm',mime:'audio/webm; codecs=vorbis'},CAF:{ext:'caf',mime:'audio/x-caf'}};static use=[Sound.FORMAT.OGG,Sound.FORMAT.MP3];static channels=4;static enabled=true;static useWebAudio;constructor(path,multiChannel)
{this.path=path;this.multiChannel=(multiChannel!==false);Object.defineProperty(this,"loop",{get:this.getLooping.bind(this),set:this.setLooping.bind(this)});this.load();}
getLooping()
{return this._loop;}
setLooping(loop)
{this._loop=loop;if(this.currentClip)this.currentClip.loop=loop;}
load(loadCallback)
{if(!Sound.enabled)
{if(loadCallback)loadCallback(this.path,true);return;}
if(KG.ready)KG.soundManager.load(this.path,this.multiChannel,loadCallback);else KG.addResource(this);}
play()
{if(!Sound.enabled)return;this.currentClip=KG.soundManager.get(this.path);this.currentClip.loop=this._loop;this.currentClip.volume=KG.soundManager.volume*this.volume;this.currentClip.play();}
stop()
{if(this.currentClip)
{this.currentClip.pause();this.currentClip.currentTime=0;}}}
class WebAudioSource
{sources=[];gain=null;buffer=null;_loop=false;constructor()
{this.gain=KG.soundManager.audioContext.createGain();this.gain.connect(KG.soundManager.audioContext.destination);Object.defineProperty(this,"loop",{get:this.getLooping.bind(this),set:this.setLooping.bind(this)});Object.defineProperty(this,"volume",{get:this.getVolume.bind(this),set:this.setVolume.bind(this)});}
play()
{if(!this.buffer)return;const source=KG.soundManager.audioContext.createBufferSource();source.buffer=this.buffer;source.connect(this.gain);source.loop=this._loop;const that=this;this.sources.push(source);source.onended=()=>that.sources.erase(source);source.start(0);}
pause()
{for(let i=0;i<this.sources.length;i++)
{try
{this.sources[i].stop();}catch(err){}}}
getLooping()
{return this._loop;}
setLooping(loop)
{this._loop=loop;for(let i=0;i<this.sources.length;i++)this.sources[i].loop=loop;}
getVolume()
{return this.gain.gain.value;}
setVolume(volume)
{this.gain.gain.value=volume;}}
class Loader
{resources=[];gameClass=null;status=0;done=false;_unloaded=[];_drawStatus=0;_intervalId=0;_loadCallbackBound=null;constructor(gameClass,resources)
{this.gameClass=gameClass;this.resources=resources;this._loadCallbackBound=this._loadCallback.bind(this);for(let i=0;i<this.resources.length;i++)this._unloaded.push(this.resources[i].path);}
load()
{KG.system.clear('#000');if(!this.resources.length)
{this.end();return;}
for(let i=0;i<this.resources.length;i++)this.loadResource(this.resources[i]);this._intervalId=setInterval(this.draw.bind(this),16);}
loadResource(res)
{res.load(this._loadCallbackBound);}
end()
{if(this.done)return;this.done=true;clearInterval(this._intervalId);KG.system.setGame(this.gameClass);}
draw()
{this._drawStatus+=(this.status-this._drawStatus)/5;const s=KG.system.scale;const w=(KG.system.width*0.6).floor();const h=(KG.system.height*0.1).floor();const x=(KG.system.width*0.5-w/2).floor();const y=(KG.system.height*0.5-h/2).floor();KG.system.context.fillStyle='#000';KG.system.context.fillRect(0,0,KG.system.width,KG.system.height);KG.system.context.fillStyle='#fff';KG.system.context.fillRect(x*s,y*s,w*s,h*s);KG.system.context.fillStyle='#000';KG.system.context.fillRect(x*s+s,y*s+s,w*s-s-s,h*s-s-s);KG.system.context.fillStyle='#fff';KG.system.context.fillRect(x*s,y*s,w*s*this._drawStatus,h*s);}
_loadCallback(path,status)
{if(status)this._unloaded.erase(path);else throw('Failed to load resource: '+path);this.status=1-(this._unloaded.length/this.resources.length);if(this._unloaded.length==0)setTimeout(this.end.bind(this),250);}}
Number.prototype.map=function(istart,istop,ostart,ostop)
{return ostart+(ostop-ostart)*((this-istart)/(istop-istart));};Number.prototype.limit=function(min,max)
{return Math.min(max,Math.max(min,this));};Number.prototype.round=function(precision)
{precision=Math.pow(10,precision||0);return Math.round(this*precision)/precision;};Number.prototype.floor=function()
{return Math.floor(this);};Number.prototype.ceil=function()
{return Math.ceil(this);};Number.prototype.toInt=function()
{return(this|0);};Number.prototype.toRad=function()
{return(this/180)*Math.PI;};Number.prototype.toDeg=function()
{return(this*180)/Math.PI;};Object.defineProperty(Array.prototype,'erase',{value:function(item)
{for(let i=this.length;i--;)
{if(this[i]===item)this.splice(i,1);}
return this;}});Object.defineProperty(Array.prototype,'random',{value:function(item)
{return this[Math.floor(Math.random()*this.length)];}});Function.prototype.bind=Function.prototype.bind||function(oThis)
{if(typeof this!=="function")throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");const aArgs=Array.prototype.slice.call(arguments,1),fToBind=this,fNOP=function(){},fBound=function()
{return fToBind.apply((this instanceof fNOP&&oThis?this:oThis),aArgs.concat(Array.prototype.slice.call(arguments)));};fNOP.prototype=this.prototype;fBound.prototype=new fNOP();return fBound;};class KG
{static game=null;static debug=null;static version='1.24';static global=window;static modules={};static resources=[];static ready=false;static nocache='';static ua={};static prefix=(window.ImpactPrefix||'');static lib='lib/';static _current=null;static _loadQueue=[];static _waitForOnload=0;static system;static input;static soundManager;static music;static ready;static main(canvasId,gameClass,fps,width,height,scale,loaderClass)
{KG.system=new System(canvasId,fps,width,height,scale||1);KG.input=new Input();KG.soundManager=new SoundManager();KG.music=new Music();KG.ready=true;const loader=new(loaderClass||Loader)(gameClass,KG.resources);loader.load();}
static $(selector)
{return selector.charAt(0)=='#'?document.getElementById(selector.substr(1)):document.getElementsByTagName(selector);}
static $new(name)
{return document.createElement(name);}
static copy(object)
{if(!object||typeof(object)!='object'||object instanceof HTMLElement)return object;else if(object instanceof Array)
{let c=[];for(let i=0,l=object.length;i<l;i++)c[i]=KG.copy(object[i]);return c;}
else
{let c={};for(let i in object)c[i]=KG.copy(object[i]);return c;}}
static ksort(obj)
{if(!obj||typeof(obj)!='object')return[];let keys=[],values=[];for(let i in obj)keys.push(i);keys.sort();for(let i=0;i<keys.length;i++)values.push(obj[keys[i]]);return values;}
static setVendorAttribute(el,attr,val)
{const uc=attr.charAt(0).toUpperCase()+attr.substr(1);el[attr]=el['ms'+uc]=el['moz'+uc]=el['webkit'+uc]=el['o'+uc]=val;}
static getVendorAttribute(el,attr)
{const uc=attr.charAt(0).toUpperCase()+attr.substr(1);return el[attr]||el['ms'+uc]||el['moz'+uc]||el['webkit'+uc]||el['o'+uc];}
static normalizeVendorAttribute(el,attr)
{const prefixedVal=KG.getVendorAttribute(el,attr);if(!el[attr]&&prefixedVal)el[attr]=prefixedVal;}
static getImagePixels(image,x,y,width,height)
{const canvas=KG.$new('canvas');canvas.width=image.width;canvas.height=image.height;const ctx=canvas.getContext('2d');System.SCALE.CRISP(canvas,ctx);const ratio=KG.getVendorAttribute(ctx,'backingStorePixelRatio')||1;KG.normalizeVendorAttribute(ctx,'getImageDataHD');const realWidth=image.width/ratio,realHeight=image.height/ratio;canvas.width=Math.ceil(realWidth);canvas.height=Math.ceil(realHeight);ctx.drawImage(image,0,0,realWidth,realHeight);return ratio===1?ctx.getImageData(x,y,width,height):ctx.getImageDataHD(x,y,width,height);}
static addResource(resource)
{KG.resources.push(resource);}
static setNocache(set)
{KG.nocache=set?'?'+Date.now():'';}
static log=function(){};static assert=function(condition,msg){};static show=function(name,number){};static mark=function(msg,color){};static boot()
{if(document.location.href.match(/\?nocache/))KG.setNocache(true);KG.ua.pixelRatio=window.devicePixelRatio||1;KG.ua.viewport={width:window.innerWidth,height:window.innerHeight};KG.ua.screen={width:window.screen.availWidth*KG.ua.pixelRatio,height:window.screen.availHeight*KG.ua.pixelRatio};KG.ua.iPhone=/iPhone|iPod/i.test(navigator.userAgent);KG.ua.iPhone4=(KG.ua.iPhone&&KG.ua.pixelRatio==2);KG.ua.iPad=/iPad/i.test(navigator.userAgent);KG.ua.android=/android/i.test(navigator.userAgent);KG.ua.winPhone=/Windows Phone/i.test(navigator.userAgent);KG.ua.iOS=KG.ua.iPhone||KG.ua.iPad;KG.ua.mobile=KG.ua.iOS||KG.ua.android||KG.ua.winPhone||/mobile/i.test(navigator.userAgent);KG.ua.touchDevice=(('ontouchstart'in window)||(window.navigator.msMaxTouchPoints));}}
KG.normalizeVendorAttribute(window,'requestAnimationFrame');if(window.requestAnimationFrame)
{let next=1,anims={};KG.setAnimation=function(callback)
{const current=next++;anims[current]=true;const animate=function()
{if(!anims[current])return;window.requestAnimationFrame(animate);callback();};window.requestAnimationFrame(animate);return current;};KG.clearAnimation=(id)=>delete anims[id];}
else
{KG.setAnimation=function(callback)
{return window.setInterval(callback,1000/60);};KG.clearAnimation=(id)=>window.clearInterval(id);}
class KGImage
{data=null;width=0;height=0;loaded=false;failed=false;loadCallback=null;path='';static drawCount=0;static cache={};static reloadCache=()=>{for(let path in KGImage.cache)KGImage.cache[path].reload();};staticInstantiate(path)
{return KGImage.cache[path]||null;}
constructor(path)
{this.path=path;this.load();}
load(loadCallback)
{if(this.loaded)
{if(loadCallback)loadCallback(this.path,true);return;}
else if(!this.loaded&&KG.ready)
{this.loadCallback=loadCallback||null;this.data=new Image();this.data.onload=this.onload.bind(this);this.data.onerror=this.onerror.bind(this);this.data.src=KG.prefix+this.path+KG.nocache;}
else KG.addResource(this);KGImage.cache[this.path]=this;}
reload()
{this.loaded=false;this.data=new Image();this.data.onload=this.onload.bind(this);this.data.src=this.path+'?'+Date.now();}
onload(event)
{this.width=this.data.width;this.height=this.data.height;this.loaded=true;if(KG.system.scale!=1)this.resize(KG.system.scale);if(this.loadCallback)this.loadCallback(this.path,true);}
onerror(event)
{this.failed=true;if(this.loadCallback)this.loadCallback(this.path,false);}
resize(scale)
{KGImage.staticResize(scale,this);}
static staticResize(scale,image)
{const origPixels=KG.getImagePixels(image.data,0,0,image.width,image.height);const widthScaled=image.width*scale;const heightScaled=image.height*scale;const scaled=KG.$new('canvas');scaled.width=widthScaled;scaled.height=heightScaled;const scaledCtx=scaled.getContext('2d');const scaledPixels=scaledCtx.getImageData(0,0,widthScaled,heightScaled);for(let y=0;y<heightScaled;y++)
{for(let x=0;x<widthScaled;x++)
{const index=(Math.floor(y/scale)*image.width+Math.floor(x/scale))*4;const indexScaled=(y*widthScaled+x)*4;scaledPixels.data[indexScaled]=origPixels.data[index];scaledPixels.data[indexScaled+1]=origPixels.data[index+1];scaledPixels.data[indexScaled+2]=origPixels.data[index+2];scaledPixels.data[indexScaled+3]=origPixels.data[index+3];}}
scaledCtx.putImageData(scaledPixels,0,0);image.data=scaled;}
draw(targetX,targetY,sourceX,sourceY,width,height)
{if(!this.loaded)return;const scale=KG.system.scale;sourceX=sourceX?sourceX*scale:0;sourceY=sourceY?sourceY*scale:0;width=(width?width:this.width)*scale;height=(height?height:this.height)*scale;KG.system.context.drawImage(this.data,sourceX,sourceY,width,height,KG.system.getDrawPos(targetX),KG.system.getDrawPos(targetY),width,height);KGImage.drawCount++;}
drawTile(targetX,targetY,tile,tileWidth,tileHeight,flipX,flipY)
{tileHeight=tileHeight?tileHeight:tileWidth;if(!this.loaded||tileWidth>this.width||tileHeight>this.height)return;const scale=KG.system.scale;const tileWidthScaled=Math.floor(tileWidth*scale);const tileHeightScaled=Math.floor(tileHeight*scale);const scaleX=flipX?-1:1;const scaleY=flipY?-1:1;if(flipX||flipY)
{KG.system.context.save();KG.system.context.scale(scaleX,scaleY);}
KG.system.context.drawImage(this.data,(Math.floor(tile*tileWidth)%this.width)*scale,(Math.floor(tile*tileWidth/this.width)*tileHeight)*scale,tileWidthScaled,tileHeightScaled,KG.system.getDrawPos(targetX)*scaleX-(flipX?tileWidthScaled:0),KG.system.getDrawPos(targetY)*scaleY-(flipY?tileHeightScaled:0),tileWidthScaled,tileHeightScaled);if(flipX||flipY)KG.system.context.restore();KGImage.drawCount++;}}
class AnimationSheet
{width=8;height=8;image=null;constructor(path,width,height)
{this.width=width;this.height=height;this.image=new KGImage(path);}}
class Animation
{sheet=null;timer=null;sequence=[];flip={x:false,y:false};pivot={x:0,y:0};frameTime=0;frame=0;tile=0;stop=false;loopCount=0;alpha=1;angle=0;constructor(sheet,frameTime,sequence,stop)
{this.sheet=sheet;this.pivot={x:sheet.width/2,y:sheet.height/2};this.timer=new Timer();this.frameTime=frameTime;this.sequence=sequence;this.stop=!!stop;this.tile=this.sequence[0];}
rewind()
{this.timer.set();this.loopCount=0;this.frame=0;this.tile=this.sequence[0];return this;}
gotoFrame(f)
{this.timer.set(this.frameTime*-f-0.0001);this.update();}
gotoRandomFrame()
{this.gotoFrame(Math.floor(Math.random()*this.sequence.length));}
update()
{const frameTotal=Math.floor(this.timer.delta()/this.frameTime);this.loopCount=Math.floor(frameTotal/this.sequence.length);if(this.stop&&this.loopCount>0)this.frame=this.sequence.length-1;else this.frame=frameTotal%this.sequence.length;this.tile=this.sequence[this.frame];}
draw(targetX,targetY)
{const bbsize=Math.max(this.sheet.width,this.sheet.height);if(targetX>KG.system.width||targetY>KG.system.height||targetX+bbsize<0||targetY+bbsize<0)return;if(this.alpha!=1)KG.system.context.globalAlpha=this.alpha;if(this.angle==0)this.sheet.image.drawTile(targetX,targetY,this.tile,this.sheet.width,this.sheet.height,this.flip.x,this.flip.y);else
{KG.system.context.save();KG.system.context.translate(KG.system.getDrawPos(targetX+this.pivot.x),KG.system.getDrawPos(targetY+this.pivot.y));KG.system.context.rotate(this.angle);this.sheet.image.drawTile(-this.pivot.x,-this.pivot.y,this.tile,this.sheet.width,this.sheet.height,this.flip.x,this.flip.y);KG.system.context.restore();}
if(this.alpha!=1)KG.system.context.globalAlpha=1;}}
class Entity
{id=0;settings={};size={x:16,y:16};offset={x:0,y:0};pos={x:0,y:0};last={x:0,y:0};vel={x:0,y:0};accel={x:0,y:0};friction={x:0,y:0};maxVel={x:100,y:100};zIndex=0;gravityFactor=1;standing=false;bounciness=0;minBounceVelocity=40;anims={};animSheet=null;currentAnim=null;health=10;type=0;checkAgainst=0;collides=0;_killed=false;slopeStanding={min:(44).toRad(),max:(136).toRad()};static _lastId=0;static COLLIDES={NEVER:0,LITE:1,PASSIVE:2,ACTIVE:4,FIXED:8};static TYPE={NONE:0,A:1,B:2,BOTH:3};constructor(x,y,settings)
{this.id=++Entity._lastId;this.pos.x=this.last.x=x;this.pos.y=this.last.y=y;this.merge(settings);}
reset(x,y,settings)
{const proto=this.constructor.prototype;this.pos.x=x;this.pos.y=y;this.last.x=x;this.last.y=y;this.vel.x=proto.vel.x;this.vel.y=proto.vel.y;this.accel.x=proto.accel.x;this.accel.y=proto.accel.y;this.health=proto.health;this._killed=proto._killed;this.standing=proto.standing;this.type=proto.type;this.checkAgainst=proto.checkAgainst;this.collides=proto.collides;this.merge(settings);}
merge(settings)
{for(let key in settings)
{const ext=settings[key];if(!this[key])this[key]=ext instanceof Array?[]:{};if(typeof ext!=='object')this[key]=ext;else this[key]=Entity.subMerge(this[key],ext);}}
static subMerge(original,extended)
{for(let key in extended)
{const ext=extended[key];if(!original[key])original[key]=ext instanceof Array?[]:{};if(typeof ext!=='object')original[key]=ext;else original=Entity.subMerge(original[key],ext);}
return original;}
addAnim(name,frameTime,sequence,stop)
{if(!this.animSheet)throw(`No animSheet to add the animation'${name}'to.`);const a=new Animation(this.animSheet,frameTime,sequence,stop);this.anims[name]=a;if(!this.currentAnim)this.currentAnim=a;return a;}
update()
{this.last.x=this.pos.x;this.last.y=this.pos.y;this.vel.y+=KG.game.gravity*KG.system.tick*this.gravityFactor;this.vel.x=this.getNewVelocity(this.vel.x,this.accel.x,this.friction.x,this.maxVel.x);this.vel.y=this.getNewVelocity(this.vel.y,this.accel.y,this.friction.y,this.maxVel.y);const mx=this.vel.x*KG.system.tick;const my=this.vel.y*KG.system.tick;const res=KG.game.collisionMap.trace(this.pos.x,this.pos.y,mx,my,this.size.x,this.size.y);this.handleMovementTrace(res);if(this.currentAnim)this.currentAnim.update();}
getNewVelocity(vel,accel,friction,max)
{if(accel)return(vel+accel*KG.system.tick).limit(-max,max);else if(friction)
{const delta=friction*KG.system.tick;if(vel-delta>0)return vel-delta;else if(vel+delta<0)return vel+delta;else return 0;}
return vel.limit(-max,max);}
handleMovementTrace(res)
{this.standing=false;if(res.collision.y)
{if(this.bounciness>0&&Math.abs(this.vel.y)>this.minBounceVelocity)this.vel.y*=-this.bounciness;else
{if(this.vel.y>0)this.standing=true;this.vel.y=0;}}
if(res.collision.x)
{if(this.bounciness>0&&Math.abs(this.vel.x)>this.minBounceVelocity)this.vel.x*=-this.bounciness;else this.vel.x=0;}
if(res.collision.slop)
{const s=res.collision.slope;if(this.bounciness>0)
{const proj=this.vel.x*s.nx+this.vel.y*s.ny;this.vel.x=(this.vel.x-s.nx*proj*2)*this.bounciness;this.vel.y=(this.vel.y-s.ny*proj*2)*this.bounciness;}
else
{const lengthSquared=s.x*s.x+s.y*s.y;const dot=(this.vel.x*s.x+this.vel.y*s.y)/lengthSquared;this.vel.x=s.x*dot;this.vel.y=s.y*dot;const angle=Math.atan2(s.x,s.y);if(angle>this.slopeStanding.min&&angle<this.slopeStanding.max)this.standing=true;}}
this.pos=res.pos;}
draw()
{if(this.currentAnim)this.currentAnim.draw(this.pos.x-this.offset.x-KG.game._rscreen.x,this.pos.y-this.offset.y-KG.game._rscreen.y);}
kill()
{KG.game.removeEntity(this);}
receiveDamage(amount,from)
{this.health-=amount;if(this.health<=0)this.kill();}
touches(other)
{return!(this.pos.x>=other.pos.x+other.size.x||this.pos.x+this.size.x<=other.pos.x||this.pos.y>=other.pos.y+other.size.y||this.pos.y+this.size.y<=other.pos.y);}
distanceTo(other)
{const xd=(this.pos.x+this.size.x/2)-(other.pos.x+other.size.x/2);const yd=(this.pos.y+this.size.y/2)-(other.pos.y+other.size.y/2);return Math.sqrt(xd*xd+yd*yd);}
angleTo(other)
{return Math.atan2((other.pos.y+other.size.y/2)-(this.pos.y+this.size.y/2),(other.pos.x+other.size.x/2)-(this.pos.x+this.size.x/2));}
check(other){}
collideWith(other,axis){}
ready(){}
erase(){}
static checkPair(a,b)
{if(a.checkAgainst&b.type)a.check(b);if(b.checkAgainst&a.type)b.check(a);if(a.collides&&b.collides&&a.collides+b.collides>Entity.COLLIDES.ACTIVE)Entity.solveCollision(a,b);}
static solveCollision(a,b)
{let weak=null;if(a.collides==Entity.COLLIDES.LITE||b.collides==Entity.COLLIDES.FIXED)weak=a;else if(b.collides==Entity.COLLIDES.LITE||a.collides==Entity.COLLIDES.FIXED)weak=b;if(a.last.x+a.size.x>b.last.x&&a.last.x<b.last.x+b.size.x)
{if(a.last.y<b.last.y)Entity.seperateOnYAxis(a,b,weak);else Entity.seperateOnYAxis(b,a,weak);a.collideWith(b,'y');b.collideWith(a,'y');}
else if(a.last.y+a.size.y>b.last.y&&a.last.y<b.last.y+b.size.y)
{if(a.last.x<b.last.x)Entity.seperateOnXAxis(a,b,weak);else Entity.seperateOnXAxis(b,a,weak);a.collideWith(b,'x');b.collideWith(a,'x');}}
static seperateOnXAxis(left,right,weak)
{const nudge=(left.pos.x+left.size.x-right.pos.x);if(weak)
{const strong=left===weak?right:left;weak.vel.x=-weak.vel.x*weak.bounciness+strong.vel.x;const resWeak=KG.game.collisionMap.trace(weak.pos.x,weak.pos.y,weak==left?-nudge:nudge,0,weak.size.x,weak.size.y);weak.pos.x=resWeak.pos.x;}
else
{const v2=(left.vel.x-right.vel.x)/2;left.vel.x=-v2;right.vel.x=v2;const resLeft=KG.game.collisionMap.trace(left.pos.x,left.pos.y,-nudge/2,0,left.size.x,left.size.y);left.pos.x=Math.floor(resLeft.pos.x);const resRight=KG.game.collisionMap.trace(right.pos.x,right.pos.y,nudge/2,0,right.size.x,right.size.y);right.pos.x=Math.ceil(resRight.pos.x);}}
static seperateOnYAxis(top,bottom,weak)
{const nudge=(top.pos.y+top.size.y-bottom.pos.y);if(weak)
{const strong=top===weak?bottom:top;weak.vel.y=-weak.vel.y*weak.bounciness+strong.vel.y;let nudgeX=0;if(weak==top&&Math.abs(weak.vel.y-strong.vel.y)<weak.minBounceVelocity)
{weak.standing=true;nudgeX=strong.vel.x*KG.system.tick;}
const resWeak=KG.game.collisionMap.trace(weak.pos.x,weak.pos.y,nudgeX,weak==top?-nudge:nudge,weak.size.x,weak.size.y);weak.pos.y=resWeak.pos.y;weak.pos.x=resWeak.pos.x;}
else if(KG.game.gravity&&(bottom.standing||top.vel.y>0))
{const resTop=KG.game.collisionMap.trace(top.pos.x,top.pos.y,0,-(top.pos.y+top.size.y-bottom.pos.y),top.size.x,top.size.y);top.pos.y=resTop.pos.y;if(top.bounciness>0&&top.vel.y>top.minBounceVelocity)top.vel.y*=-top.bounciness;else
{top.standing=true;top.vel.y=0;}}
else
{const v2=(top.vel.y-bottom.vel.y)/2;top.vel.y=-v2;bottom.vel.y=v2;const nudgeX=bottom.vel.x*KG.system.tick;const resTop=KG.game.collisionMap.trace(top.pos.x,top.pos.y,nudgeX,-nudge/2,top.size.x,top.size.y);top.pos.y=resTop.pos.y;const resBottom=KG.game.collisionMap.trace(bottom.pos.x,bottom.pos.y,0,nudge/2,bottom.size.x,bottom.size.y);bottom.pos.y=resBottom.pos.y;}}}
class Map
{tilesize=8;width=1;height=1;pxWidth=1;pxHeight=1;data=[[]];name=null;constructor(tilesize,data)
{this.tilesize=tilesize;this.data=data;this.height=data.length;this.width=data[0].length;this.pxWidth=this.width*this.tilesize;this.pxHeight=this.height*this.tilesize;}
getTile(x,y)
{const tx=Math.floor(x/this.tilesize);const ty=Math.floor(y/this.tilesize);if((tx>=0&&tx<this.width)&&(ty>=0&&ty<this.height))return this.data[ty][tx];else return 0;}
setTile(x,y,tile)
{const tx=Math.floor(x/this.tilesize);const ty=Math.floor(y/this.tilesize);if((tx>=0&&tx<this.width)&&(ty>=0&&ty<this.height))this.data[ty][tx]=tile;}}
class CollisionMap extends Map
{lastSlope=1;tiledef=null;static H=1/2;static N=1/3;static M=2/3;static SOLID=true;static NON_SOLID=false;static defaultTileDef={5:[0,1,1,CollisionMap.M,CollisionMap.SOLID],6:[0,CollisionMap.M,1,CollisionMap.N,CollisionMap.SOLID],7:[0,CollisionMap.N,1,0,CollisionMap.SOLID],3:[0,1,1,CollisionMap.H,CollisionMap.SOLID],4:[0,CollisionMap.H,1,0,CollisionMap.SOLID],2:[0,1,1,0,CollisionMap.SOLID],10:[CollisionMap.H,1,1,0,CollisionMap.SOLID],21:[0,1,CollisionMap.H,0,CollisionMap.SOLID],32:[CollisionMap.M,1,1,0,CollisionMap.SOLID],43:[CollisionMap.N,1,CollisionMap.M,0,CollisionMap.SOLID],54:[0,1,CollisionMap.N,0,CollisionMap.SOLID],27:[0,0,1,CollisionMap.N,CollisionMap.SOLID],28:[0,CollisionMap.N,1,CollisionMap.M,CollisionMap.SOLID],29:[0,CollisionMap.M,1,1,CollisionMap.SOLID],25:[0,0,1,CollisionMap.H,CollisionMap.SOLID],26:[0,CollisionMap.H,1,1,CollisionMap.SOLID],24:[0,0,1,1,CollisionMap.SOLID],11:[0,0,CollisionMap.H,1,CollisionMap.SOLID],22:[CollisionMap.H,0,1,1,CollisionMap.SOLID],33:[0,0,CollisionMap.N,1,CollisionMap.SOLID],44:[CollisionMap.N,0,CollisionMap.M,1,CollisionMap.SOLID],55:[CollisionMap.M,0,1,1,CollisionMap.SOLID],16:[1,CollisionMap.N,0,0,CollisionMap.SOLID],17:[1,CollisionMap.M,0,CollisionMap.N,CollisionMap.SOLID],18:[1,1,0,CollisionMap.M,CollisionMap.SOLID],14:[1,CollisionMap.H,0,0,CollisionMap.SOLID],15:[1,1,0,CollisionMap.H,CollisionMap.SOLID],13:[1,1,0,0,CollisionMap.SOLID],8:[CollisionMap.H,1,0,0,CollisionMap.SOLID],19:[1,1,CollisionMap.H,0,CollisionMap.SOLID],30:[CollisionMap.N,1,0,0,CollisionMap.SOLID],41:[CollisionMap.M,1,CollisionMap.N,0,CollisionMap.SOLID],52:[1,1,CollisionMap.M,0,CollisionMap.SOLID],38:[1,CollisionMap.M,0,1,CollisionMap.SOLID],39:[1,CollisionMap.N,0,CollisionMap.M,CollisionMap.SOLID],40:[1,0,0,CollisionMap.N,CollisionMap.SOLID],36:[1,CollisionMap.H,0,1,CollisionMap.SOLID],37:[1,0,0,CollisionMap.H,CollisionMap.SOLID],35:[1,0,0,1,CollisionMap.SOLID],9:[1,0,CollisionMap.H,1,CollisionMap.SOLID],20:[CollisionMap.H,0,0,1,CollisionMap.SOLID],31:[1,0,CollisionMap.M,1,CollisionMap.SOLID],42:[CollisionMap.M,0,CollisionMap.N,1,CollisionMap.SOLID],53:[CollisionMap.N,0,0,1,CollisionMap.SOLID],12:[0,0,1,0,CollisionMap.NON_SOLID],23:[1,1,0,1,CollisionMap.NON_SOLID],34:[1,0,1,1,CollisionMap.NON_SOLID],45:[0,1,0,0,CollisionMap.NON_SOLID]};static staticNoCollision={trace:function(x,y,vx,vy)
{return{collision:{x:false,y:false,slope:false},pos:{x:x+vx,y:y+vy},tile:{x:0,y:0}};}};constructor(tilesize,data,tiledef)
{super(tilesize,data);this.tiledef=tiledef||CollisionMap.defaultTileDef;for(let t in this.tiledef)
{if(t|0>this.lastSlope)this.lastSlope=t|0;}}
trace(x,y,vx,vy,objectWidth,objectHeight)
{const res={collision:{x:false,y:false,slope:false},pos:{x:x,y:y},tile:{x:0,y:0}};const steps=Math.ceil((Math.max(Math.abs(vx),Math.abs(vy))+0.1)/this.tilesize);if(steps>1)
{let sx=vx/steps;let sy=vy/steps;for(let i=0;i<steps&&(sx||sy);i++)
{this._traceStep(res,x,y,sx,sy,objectWidth,objectHeight,vx,vy,i);x=res.pos.x;y=res.pos.y;if(res.collision.x)
{sx=0;vx=0;}
if(res.collision.y)
{sy=0;vy=0;}
if(res.collision.slope)break;}}
else this._traceStep(res,x,y,vx,vy,objectWidth,objectHeight,vx,vy,0);return res;}
_traceStep(res,x,y,vx,vy,width,height,rvx,rvy,step)
{res.pos.x+=vx;res.pos.y+=vy;let t=0;if(vx)
{const pxOffsetX=(vx>0?width:0);const tileOffsetX=(vx<0?this.tilesize:0);const firstTileY=Math.max(Math.floor(y/this.tilesize),0);const lastTileY=Math.min(Math.ceil((y+height)/this.tilesize),this.height);const tileX=Math.floor((res.pos.x+pxOffsetX)/this.tilesize);let prevTileX=Math.floor((x+pxOffsetX)/this.tilesize);if(step>0||tileX==prevTileX||prevTileX<0||prevTileX>=this.width)prevTileX=-1;if(tileX>=0&&tileX<this.width)
{for(let tileY=firstTileY;tileY<lastTileY;tileY++)
{if(prevTileX!=-1)
{t=this.data[tileY][prevTileX];if(t>1&&t<=this.lastSlope&&this._checkTileDef(res,t,x,y,rvx,rvy,width,height,prevTileX,tileY))break;}
t=this.data[tileY][tileX];if(t==1||t>this.lastSlope||(t>1&&this._checkTileDef(res,t,x,y,rvx,rvy,width,height,tileX,tileY)))
{if(t>1&&t<=this.lastSlope&&res.collision.slope)break;res.collision.x=true;res.tile.x=t;x=res.pos.x=tileX*this.tilesize-pxOffsetX+tileOffsetX;rvx=0;break;}}}}
if(vy)
{const pxOffsetY=(vy>0?height:0);const tileOffsetY=(vy<0?this.tilesize:0);const firstTileX=Math.max(Math.floor(res.pos.x/this.tilesize),0);const lastTileX=Math.min(Math.ceil((res.pos.x+width)/this.tilesize),this.width);const tileY=Math.floor((res.pos.y+pxOffsetY)/this.tilesize);let prevTileY=Math.floor((y+pxOffsetY)/this.tilesize);if(step>0||tileY==prevTileY||prevTileY<0||prevTileY>=this.height)prevTileY=-1;if(tileY>=0&&tileY<this.height)
{for(let tileX=firstTileX;tileX<lastTileX;tileX++)
{if(prevTileY!=-1)
{t=this.data[prevTileY][tileX];if(t>1&&t<=this.lastSlope&&this._checkTileDef(res,t,x,y,rvx,rvy,width,height,tileX,prevTileY))break;}
t=this.data[tileY][tileX];if(t==1||t>this.lastSlope||(t>1&&this._checkTileDef(res,t,x,y,rvx,rvy,width,height,tileX,tileY)))
{if(t>1&&t<=this.lastSlope&&res.collision.slope)break;res.collision.y=true;res.tile.y=t;res.pos.y=tileY*this.tilesize-pxOffsetY+tileOffsetY;break;}}}}}
_checkTileDef(res,t,x,y,vx,vy,width,height,tileX,tileY)
{const def=this.tiledef[t];if(!def)return false;const lx=(tileX+def[0])*this.tilesize,ly=(tileY+def[1])*this.tilesize,lvx=(def[2]-def[0])*this.tilesize,lvy=(def[3]-def[1])*this.tilesize,solid=def[4];const tx=x+vx+(lvy<0?width:0)-lx,ty=y+vy+(lvx>0?height:0)-ly;if(lvx*ty-lvy*tx>0)
{if(vx*-lvy+vy*lvx<0)return solid;const length=Math.sqrt(lvx*lvx+lvy*lvy);const nx=lvy/length,ny=-lvx/length;const proj=tx*nx+ty*ny;const px=nx*proj,py=ny*proj;if(px*px+py*py>=vx*vx+vy*vy)return solid||(lvx*(ty-vy)-lvy*(tx-vx)<0.5);res.pos.x=x+vx-px;res.pos.y=y+vy-py;res.collision.slope={x:lvx,y:lvy,nx:nx,ny:ny};return true;}
return false;}}
class BackgroundMap extends Map
{tiles=null;scroll={x:0,y:0};distance=1;repeat=false;tilesetName='';foreground=false;enabled=true;preRender=false;preRenderedChunks=null;chunkSize=512;debugChunks=false;anims={};constructor(tilesize,data,tileset)
{super(tilesize,data);this.setTileset(tileset);}
setTileset(tileset)
{this.tilesetName=tileset instanceof KGImage?tileset.path:tileset;this.tiles=new KGImage(this.tilesetName);this.preRenderedChunks=null;}
setScreenPos(x,y)
{this.scroll.x=x/this.distance;this.scroll.y=y/this.distance;}
preRenderMapToChunks()
{const totalWidth=this.width*this.tilesize*KG.system.scale,totalHeight=this.height*this.tilesize*KG.system.scale;this.chunkSize=Math.min(Math.max(totalWidth,totalHeight),this.chunkSize);const chunkCols=Math.ceil(totalWidth/this.chunkSize),chunkRows=Math.ceil(totalHeight/this.chunkSize);this.preRenderedChunks=[];for(let y=0;y<chunkRows;y++)
{this.preRenderedChunks[y]=[];for(let x=0;x<chunkCols;x++)
{const chunkWidth=(x==chunkCols-1)?totalWidth-x*this.chunkSize:this.chunkSize;const chunkHeight=(y==chunkRows-1)?totalHeight-y*this.chunkSize:this.chunkSize;this.preRenderedChunks[y][x]=this.preRenderChunk(x,y,chunkWidth,chunkHeight);}}}
preRenderChunk(cx,cy,w,h)
{const tw=w/this.tilesize/KG.system.scale+1,th=h/this.tilesize/KG.system.scale+1;const nx=(cx*this.chunkSize/KG.system.scale)%this.tilesize,ny=(cy*this.chunkSize/KG.system.scale)%this.tilesize;const tx=Math.floor(cx*this.chunkSize/this.tilesize/KG.system.scale),ty=Math.floor(cy*this.chunkSize/this.tilesize/KG.system.scale);const chunk=KG.$new('canvas');chunk.width=w;chunk.height=h;chunk.retinaResolutionEnabled=false;const chunkContext=chunk.getContext('2d');System.scaleMode(chunk,chunkContext);const screenContext=KG.system.context;KG.system.context=chunkContext;for(let x=0;x<tw;x++)
{for(let y=0;y<th;y++)
{if(x+tx<this.width&&y+ty<this.height)
{const tile=this.data[y+ty][x+tx];if(tile)this.tiles.drawTile(x*this.tilesize-nx,y*this.tilesize-ny,tile-1,this.tilesize);}}}
KG.system.context=screenContext;const image=new Image();image.src=chunk.toDataURL();image.width=chunk.width;image.height=chunk.height;return image;}
draw()
{if(!this.tiles.loaded||!this.enabled)return;if(this.preRender)this.drawPreRendered();else this.drawTiled();}
drawPreRendered()
{if(!this.preRenderedChunks)this.preRenderMapToChunks();let dx=KG.system.getDrawPos(this.scroll.x),dy=KG.system.getDrawPos(this.scroll.y);if(this.repeat)
{const w=this.width*this.tilesize*KG.system.scale;dx=(dx%w+w)%w;const h=this.height*this.tilesize*KG.system.scale;dy=(dy%h+h)%h;}
let minChunkX=Math.max(Math.floor(dx/this.chunkSize),0),minChunkY=Math.max(Math.floor(dy/this.chunkSize),0),maxChunkX=Math.ceil((dx+KG.system.realWidth)/this.chunkSize),maxChunkY=Math.ceil((dy+KG.system.realHeight)/this.chunkSize),maxRealChunkX=this.preRenderedChunks[0].length,maxRealChunkY=this.preRenderedChunks.length;if(!this.repeat)
{maxChunkX=Math.min(maxChunkX,maxRealChunkX);maxChunkY=Math.min(maxChunkY,maxRealChunkY);}
let nudgeY=0;for(let cy=minChunkY;cy<maxChunkY;cy++)
{let nudgeX=0;for(let cx=minChunkX;cx<maxChunkX;cx++)
{const chunk=this.preRenderedChunks[cy%maxRealChunkY][cx%maxRealChunkX];const x=-dx+cx*this.chunkSize-nudgeX;const y=-dy+cy*this.chunkSize-nudgeY;KG.system.context.drawImage(chunk,x,y);KGImage.drawCount++;if(this.debugChunks)
{KG.system.context.strokeStyle='#f0f';KG.system.context.strokeRect(x,y,this.chunkSize,this.chunkSize);}
if(this.repeat&&chunk.width<this.chunkSize&&x+chunk.width<KG.system.realWidth)
{nudgeX+=this.chunkSize-chunk.width;if(cy==minChunkY)maxChunkX++;}}
if(this.repeat&&chunk.height<this.chunkSize&&y+chunk.height<KG.system.realHeight)
{nudgeY+=this.chunkSize-chunk.height;maxChunkY++;}}}
drawTiled()
{let tile=0,anim=null,tileOffsetX=(this.scroll.x/this.tilesize).toInt(),tileOffsetY=(this.scroll.y/this.tilesize).toInt(),pxOffsetX=this.scroll.x%this.tilesize,pxOffsetY=this.scroll.y%this.tilesize,pxMinX=-pxOffsetX-this.tilesize,pxMinY=-pxOffsetY-this.tilesize,pxMaxX=KG.system.width+this.tilesize-pxOffsetX,pxMaxY=KG.system.height+this.tilesize-pxOffsetY;for(let mapY=-1,pxY=pxMinY;pxY<pxMaxY;mapY++,pxY+=this.tilesize)
{let tileY=mapY+tileOffsetY;if(tileY>=this.height||tileY<0)
{if(!this.repeat)continue;tileY=(tileY%this.height+this.height)%this.height;}
for(let mapX=-1,pxX=pxMinX;pxX<pxMaxX;mapX++,pxX+=this.tilesize)
{let tileX=mapX+tileOffsetX;if(tileX>=this.width||tileX<0)
{if(!this.repeat)continue;tileX=(tileX%this.width+this.width)%this.width;}
if((tile=this.data[tileY][tileX]))
{if((anim=this.anims[tile-1]))anim.draw(pxX,pxY);else this.tiles.drawTile(pxX,pxY,tile-1,this.tilesize);}}}}}
const animation=new AnimationSheet('media/square.png',16,16);class EntityPlayer extends Entity
{size={x:16,y:16};collides=Entity.COLLIDES.FIXED;animSheet=animation;constructor(x,y,settings)
{super(x,y,settings);this.addAnim('idle',1,[0]);}
update()
{const up=KG.input.state('up')?1:0,down=KG.input.state('down')?1:0,right=KG.input.state('right')?1:0,left=KG.input.state('left')?1:0;this.vel.x=(right-left)*500;this.vel.y=(down-up)*500;super.update();}}
class Game
{clearColor='#000000';gravity=0;screen={x:0,y:0};_rscreen={x:0,y:0};entities=[];namedEntities={};collisionMap=CollisionMap.staticNoCollision;backgroundMaps=[];backgroundAnims={};autoSort=false;sortBy=null;cellSize=64;_deferredKill=[];_levelToLoad=null;_doSortEntities=false;static SORT={Z_INDEX:function(a,b){return a.zIndex-b.zIndex;},POS_X:function(a,b){return(a.pos.x+a.size.x)-(b.pos.x+b.size.x);},POS_Y:function(a,b){return(a.pos.y+a.size.y)-(b.pos.y+b.size.y);}};constructor()
{this.sortBy=this.sortBy||Game.SORT.Z_INDEX;KG.game=this;}
static staticInstantiate()
{this.sortBy=this.sortBy||Game.SORT.Z_INDEX;KG.game=this;return null;}
loadLevel(data)
{this.screen={x:0,y:0};this.entities=[];this.namedEntities={};for(let i=0;i<data.entities.length;i++)
{const ent=data.entities[i];this.spawnEntity(ent.type,ent.x,ent.y,ent.settings);}
this.sortEntities();this.collisionMap=CollisionMap.staticNoCollision;this.backgroundMaps=[];for(let i=0;i<data.layer.length;i++)
{const ld=data.layer[i];if(ld.name=='collision')this.collisionMap=new CollisionMap(ld.tilesize,ld.data);else
{const newMap=new BackgroundMap(ld.tilesize,ld.data,ld.tilesetName);newMap.anims=this.backgroundAnims[ld.tilesetName]||{};newMap.repeat=ld.repeat;newMap.distance=ld.distance;newMap.foreground=!!ld.foreground;newMap.preRender=!!ld.preRender;newMap.name=ld.name;this.backgroundMaps.push(newMap);}}
for(let i=0;i<this.entities.length;i++)this.entities[i].ready();}
loadLevelDeferred(data)
{this._levelToLoad=data;}
getMapByName(name)
{if(name=='collision')return this.collisionMap;for(let i=0;i<this.backgroundMaps.length;i++)
{if(this.backgroundMaps[i].name==name)return this.backgroundMaps[i];}
return null;}
getEntityByName(name)
{return this.namedEntities[name];}
getEntitiesByType(type)
{const entityClass=typeof(type)==='string'?KG.global[type]:type;let a=[];for(let i=0;i<this.entities.length;i++)
{const ent=this.entities[i];if(ent instanceof entityClass&&!ent._killed)a.push(ent);}
return a;}
spawnEntity(type,x,y,settings)
{const entityClass=typeof(type)==='string'?Entities[type]:type;if(!entityClass)throw("Can't spawn entity of type "+type);const ent=new(entityClass)(x,y,settings||{});this.entities.push(ent);if(ent.name)this.namedEntities[ent.name]=ent;return ent;}
sortEntities()
{this.entities.sort(this.sortBy);}
sortEntitiesDeferred()
{this._doSortEntities=true;}
removeEntity(ent)
{if(ent.name)delete this.namedEntities[ent.name];ent._killed=true;ent.type=Entity.TYPE.NONE;ent.checkAgainst=Entity.TYPE.NONE;ent.collides=Entity.COLLIDES.NEVER;this._deferredKill.push(ent);}
run()
{this.update();this.draw();}
update()
{if(this._levelToLoad)
{this.loadLevel(this._levelToLoad);this._levelToLoad=null;}
this.updateEntities();this.checkEntities();for(let i=0;i<this._deferredKill.length;i++)
{this._deferredKill[i].erase();this.entities.erase(this._deferredKill[i]);}
this._deferredKill=[];if(this._doSortEntities||this.autoSort)
{this.sortEntities();this._doSortEntities=false;}
for(let tileset in this.backgroundAnims)
{const anims=this.backgroundAnims[tileset];for(let a in anims)anims[a].update();}}
updateEntities()
{for(let i=0;i<this.entities.length;i++)
{const ent=this.entities[i];if(!ent._killed)ent.update();}}
draw()
{if(this.clearColor)KG.system.clear(this.clearColor);this._rscreen.x=KG.system.getDrawPos(this.screen.x)/KG.system.scale;this._rscreen.y=KG.system.getDrawPos(this.screen.y)/KG.system.scale;let mapIndex;for(mapIndex=0;mapIndex<this.backgroundMaps.length;mapIndex++)
{const map=this.backgroundMaps[mapIndex];if(map.foreground)break;map.setScreenPos(this.screen.x,this.screen.y);map.draw();}
this.drawEntities();for(mapIndex;mapIndex<this.backgroundMaps.length;mapIndex++)
{const map=this.backgroundMaps[mapIndex];map.setScreenPos(this.screen.x,this.screen.y);map.draw();}}
drawEntities()
{for(let i=0;i<this.entities.length;i++)this.entities[i].draw();}
checkEntities()
{let hash={};for(let e=0;e<this.entities.length;e++)
{const entity=this.entities[e];if(entity.type==Entity.TYPE.NONE&&entity.checkAgainst==Entity.TYPE.NONE&&entity.collides==Entity.COLLIDES.NEVER)continue;let checked={};const xmin=Math.floor(entity.pos.x/this.cellSize),ymin=Math.floor(entity.pos.y/this.cellSize),xmax=Math.floor((entity.pos.x+entity.size.x)/this.cellSize)+1,ymax=Math.floor((entity.pos.y+entity.size.y)/this.cellSize)+1;for(let x=xmin;x<xmax;x++)
{for(let y=ymin;y<ymax;y++)
{if(!hash[x])
{hash[x]={};hash[x][y]=[entity];}
else if(!hash[x][y])hash[x][y]=[entity];else
{let cell=hash[x][y];for(let c=0;c<cell.length;c++)
{if(entity.touches(cell[c])&&!checked[cell[c].id])
{checked[cell[c].id]=true;Entity.checkPair(entity,cell[c]);}}
cell.push(entity);}}}}}}
class Font extends KGImage
{widthMap=[];indices=[];firstChar=32;alpha=1;letterSpacing=1;lineSpacing=0;static ALIGN={LEFT:0,RIGHT:1,CENTER:2};onload(ev)
{this._loadMetrics(this.data);super.onload(ev);this.height-=2;}
widthForString(text)
{if(text.indexOf('\n')!==-1)
{const lines=text.split('\n');let width=0;for(let i=0;i<lines.length;i++)width=Math.max(width,this._widthForLine(lines[i]));return width;}
else return this._widthForLine(text);}
_widthForLine(text)
{let width=0;for(let i=0;i<text.length;i++)width+=this.widthMap[text.charCodeAt(i)-this.firstChar];if(text.length>0)width+=this.letterSpacing*(text.length-1);return width;}
heightForString(text)
{return text.split('\n').length*(this.height+this.lineSpacing);}
draw(text,x,y,align)
{if(typeof(text)!='string')text=text.toString();if(text.indexOf('\n')!==-1)
{const lines=text.split('\n');const lineHeight=this.height+this.lineSpacing;for(let i=0;i<lines.length;i++)this.draw(lines[i],x,y+i*lineHeight,align);return;}
if(align==Font.ALIGN.RIGHT||align==Font.ALIGN.CENTER)
{const width=this._widthForLine(text);x-=align==Font.ALIGN.CENTER?width/2:width;}
if(this.alpha!==1)KG.system.context.globalAlpha=this.alpha;for(let i=0;i<text.length;i++)
{const c=text.charCodeAt(i);x+=this._drawChar(c-this.firstChar,x,y);}
if(this.alpha!==1)KG.system.context.globalAlpha=1;KGImage.drawCount+=text.length;}
_drawChar(c,targetX,targetY)
{if(!this.loaded||c<0||c>=this.indices.length)return 0;const scale=KG.system.scale;const charX=this.indices[c]*scale;const charY=0;const charWidth=this.widthMap[c]*scale;const charHeight=this.height*scale;KG.system.context.drawImage(this.data,charX,charY,charWidth,charHeight,KG.system.getDrawPos(targetX),KG.system.getDrawPos(targetY),charWidth,charHeight);return this.widthMap[c]+this.letterSpacing;}
_loadMetrics(image)
{this.widthMap=[];this.indices=[];const px=KG.getImagePixels(image,0,image.height-1,image.width,1);let currentWidth=0;let x;for(x=0;x<image.width;x++)
{let index=x*4+3;if(px.data[index]>127)currentWidth++;else if(px.data[index]<128&&currentWidth)
{this.widthMap.push(currentWidth);this.indices.push(x-currentWidth);currentWidth=0;}}
this.widthMap.push(currentWidth);this.indices.push(x-currentWidth);}}
const LevelTest={"entities":[{"type":"EntityPlayer","x":64,"y":64,"settings":{"size":{"x":128,"y":128}}}],"layer":[]};const font=new Font('media/04b03.font.png');class MyGame extends Game
{font=font;constructor()
{super();KG.input.bind(Input.KEY.UP_ARROW,'up');KG.input.bind(Input.KEY.DOWN_ARROW,'down');KG.input.bind(Input.KEY.RIGHT_ARROW,'right');KG.input.bind(Input.KEY.LEFT_ARROW,'left');this.loadLevel(LevelTest);}
update()
{super.update();}
draw()
{super.draw();const x=KG.system.width/2,y=KG.system.height/2;this.font.draw('It Works!',x,y,Font.ALIGN.CENTER);}}
KG.main('#canvas',MyGame,60,320,240,2);